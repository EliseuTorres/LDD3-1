1. Kobject, kobj_type, and kset:
Kobject subsystem handles the generation of events that notify user space about the comings and goings of hardware on the system.
i) Kobject basics (also see LKD/chapter_17):
It's rare for kernel code to create a standalone kobject, instead, kobjects are always found embedded in other structures.

• kobject initialization:
* The first is to set the entire kobject to 0, usually with a call to memset(). Failure to zero out a kobject often leads to very strange crashes further down the line, this step shouldn't be omitted.
* The next step is to set up some of the internal fields with a call to kobject_init(): (also see LKD/chapter_17)
	void kobject_init(struct kobject *kobj, struct kobj_type *ktype);
	int kobject_set_name(struct kobject *kobj, const char *fmt, ...); // set the name of the kobject, which is used in sysfs entries. Note that this call may fail, so you should check its return value.

• Reference count manipulation:
	struct kobject *kobject_get(struct kobject *kobj); // Increase kobj's ref_cnt by 1.
	void kobject_put(struct kobject *kobj);  // Decrease kobj's ref_cnt by 1, and if it becomes 0, the release() function pointed at by the kobj_type associated with the kobject is invoked.
Note that in many cases, the reference count in the kobject itself may not be sufficient to prevent race conditions. The existence of a kobject may require the continued existence of the module that created that kobject. It would not do to unload that module while the kobject is still being passed around. See source code of cdev_get().

• Release functions and kobj_type:
Every kobject must have a release() method, which is embedded in kobj_type.
	struct kobj_type *get_ktype(struct kobject *kobj);  // finds the kobj_type pointer for a given kobject.

• kobject hierarchies, kset:
* kobject structure has a parent pointer, which is used to position the object in the sysfs hierarchy.
* kset is used as containment, it can be thought of as the top-level container class for kobjects. It's worth noting that ksets are always represented in sysfs once a kset has been set up and added to the system, there will be a sysfs directory for it. Kobjects do not necessarily show up in sysfs, but every kobject that is a member of a kset is represented there.
	int kobject_add(struct kobject *kobj, struct kobject *parent, const char *fmt, ...); // see LKD/chapter_17 for more details.
	void kobject_del(struct kobject *kobj); // Remove a kobject's sysfs representation
* A kset keeps its children in a standard kernel linked list. In almost all cases, the contained kobjects also have pointers (parent pointer) to the kset (or strictly, kset's embedded kobject)
        ----------------------
        | kset   ----------- | 
|------>|        | kobject | |----------     ----> : kset child list
|       ----------------------         |           
|         ^  ^        ^   ^            |         ^
|        // //       /   /             |        // : kobject->kset
|                                      |
|   -----------		 -----------       |        ^
<---| kobject | <--- | kobject | <------       /   : kobject->parent
    -----------      -----------

* Operations on kset:
	void kset_init(struct kset *kset);  
	int kset_register(struct kset *kset); // initialize and add a kset
	void kset_unregister(struct kset *kset);
	struct kset *kset_get(struct kset *kset); // manage the reference counts of ksets.
	void kset_put(struct kset *kset);
Note that a kset's ref_cnt is actually its embedded kobject's reference count.


2. Low-level sysfs operations:
For every directory found in sysfs, there is a kobject lurking somewhere within the kernel (kobject is embedded in kset). Every kobject of interest also exports one or more attributes, which appear in that kobject's sysfs directory as files containing kernel-generated information.
• kobject_add() see LKD/chapter_17's notes. Sysfs entries for kobjects are always directories, so a call to kobject_add() results in the creation of a directory in sysfs. Usually that directory contains one or more attributes.
i)   Default attributes:
When created, every kobject is given a set of default attributes. These attributes are specified by way of the kobj_type structure:
	struct kobj_type {
		void (*release)(struct kobject *);
		struct sysfs_ops *sysfs_ops;
		struct attribute **default_attrs;
	};
The @default_attrs field lists the attributes to be created for _EVERY_ kobject of this type, and sysfs_ops provides the methods to implement those attributes. Note that the last entry in @default_attrs must be NULL.
	struct sysfs_ops {
		ssize_t (*show)(struct kobject *kobj, struct attribute *attr, char *buffer);
		ssize_t (*store)(struct kobject *kobj, struct attribute *attr, const char *buffer, size_t size);
	};
The same show/store method is used for all attributes associated with a given kobject. (See fs/sysfs/file.c: fill_read_buffer(), flush_write_buffer(). See also drivers/base/core.c: device_initialize(), device_ktype, etc.) The show() method should encode the value into buffer, which length is limited to PAGE_SIZE. The store() method should decode the data stored in buffer and respond to the kernel, note that you should validate it carefully because it comes from user space.
• Nondefault attributes:
If you wish to add a new attribute to a kobject's sysfs directory:
	int sysfs_create_file(struct kobject *kobj, struct attribute *attr);
Note that the same show() and store() functions are called to implement operations on the new attribute.

ii)  Binary attributes:
Here's need to pass large chunks of binary data between user space and kernel space, like uploading firmware to devices. 
	struct bin_attribute {
		struct attribute attr;
		size_t size;
		void *private;
		ssize_t (*read)(struct kobject *kobj, struct bin_attribute *bin_attr, char *buffer, loff_t pos, size_t size);
		ssize_t (*write)(struct kobject *kobj, struct bin_attribute *bin_attr, char *buffer, loff_t pos, size_t size);
		int (*mmap)(struct kobject *kobj, struct bin_attribute *bin_attr, struct vm_area_struct *vma);
	};
The @size is the maximum size of the binary attribute (or 0 if there is no maximum). Note there's no way for sysfs to signal the last of a set of write operations, so code implementing a binary attribute must be able to determine the end of the data some other way.
	int sysfs_create_bin_file(struct kobject *kobj, struct bin_attribute *attr);
	int sysfs_remove_bin_file(struct kobject *kobj, struct bin_attribute *attr);

iii) Symbolic links:
	int sysfs_create_link(struct kobject *kobj, struct kobject *target, const char *name); // Creates a link (called @name) pointing to target's sysfs entry as an attribute of kobj.
	void sysfs_remove_link(struct kobject *kobj, const char *name);
Note that the link persists even if target is removed from the system. So you should probably have a way of knowing about changes to those kobjects or some sort of assurance that the target kobjects will not disappear.

iv)  Hotplug event generation (uevent):
A hotplug event is a notification to user space from the kernel that something has changed in the system's configuration. They are generated whenever(after) a kobject is created or destroyed. Before the event is handed to user space, code associated with the kobject (or more specifically the kset to which it belongs) has the opportunity to add information for user space or to disable event generation entirely.
	struct kset_uevent_ops {
		int (*filter)(struct kset *kset, struct kobject *kobj);
		const char *(*name)(struct kset *kset, struct kobject *kobj);
		int (*uevent)(struct kset *kset, struct kobject *kobj, struct kobj_uevent_env *env);
	};
	struct kobj_uevent_env {
		char *envp[UEVENT_NUM_ENVP];
		int envp_idx;
		char buf[UEVENT_BUFFER_SIZE];
		int buflen;
	};
• A pointer to this structure is found in the @kset_uevent_ops field of the kset structure. If a given kobject is not contained within a kset, the kernel searches up through the hierarchy (use parent pointer) until it finds a kobject that does have a kset, that kset's kset_uevent_ops is then used.
• The @filter function is called whenever kernel is considering generating an event for a given kobject. If filter() returns 0, the event is not created. This method thus gives kset code an opportunity to decide which events should be passed on to user space. (See the source code of kobject_uevent_env().)
• The @name function should return a simple string suitable for passing to user space.
• The final @uevent function gives an opportunity to add useful environment variables prior to the invocation of that (user-space) script. The @envp array is used to store additional environment variable definitions (in the NAME=value format). It has @envp_idx entries in total. The variables themselves should be encoded into @buf, which is @buflen bytes long. Be sure to use NULL as the last entry in the envp. The return value should normally be 0, any nonzero return aborts the generation of the hotplug event.


3. Buses, devices, and drivers:

