1. Kobject, kobj_type, and kset:
Kobject subsystem handles the generation of events that notify user space about the comings and goings of hardware on the system.
i) Kobject basics (also see LKD/chapter_17):
It's rare for kernel code to create a standalone kobject, instead, kobjects are always found embedded in other structures.

• kobject initialization:
* The first is to set the entire kobject to 0, usually with a call to memset(). Failure to zero out a kobject often leads to very strange crashes further down the line, this step shouldn't be omitted.
* The next step is to set up some of the internal fields with a call to kobject_init(): (also see LKD/chapter_17)
	void kobject_init(struct kobject *kobj, struct kobj_type *ktype);
	int kobject_set_name(struct kobject *kobj, const char *fmt, ...); // set the name of the kobject, which is used in sysfs entries. Note that this call may fail, so you should check its return value.

• Reference count manipulation:
	struct kobject *kobject_get(struct kobject *kobj); // Increase kobj's ref_cnt by 1.
	void kobject_put(struct kobject *kobj);  // Decrease kobj's ref_cnt by 1, and if it becomes 0, the release() function pointed at by the kobj_type associated with the kobject is invoked.
Note that in many cases, the reference count in the kobject itself may not be sufficient to prevent race conditions. The existence of a kobject may require the continued existence of the module that created that kobject. It would not do to unload that module while the kobject is still being passed around. See source code of cdev_get().

• Release functions and kobj_type:
Every kobject must have a release() method, which is embedded in kobj_type.
	struct kobj_type *get_ktype(struct kobject *kobj);  // finds the kobj_type pointer for a given kobject.

• kobject hierarchies, kset:
* kobject structure has a parent pointer, which is used to position the object in the sysfs hierarchy.
* kset is used as containment, it can be thought of as the top-level container class for kobjects. It's worth noting that ksets are always represented in sysfs once a kset has been set up and added to the system, there will be a sysfs directory for it. Kobjects do not necessarily show up in sysfs, but every kobject that is a member of a kset is represented there.
	int kobject_add(struct kobject *kobj, struct kobject *parent, const char *fmt, ...); // see LKD/chapter_17 for more details.
	void kobject_del(struct kobject *kobj); // Remove a kobject's sysfs representation
* A kset keeps its children in a standard kernel linked list. In almost all cases, the contained kobjects also have pointers (parent pointer) to the kset (or strictly, kset's embedded kobject)
        ----------------------
        | kset   ----------- | 
|------>|        | kobject | |----------     ----> : kset child list
|       ----------------------         |           
|         ^  ^        ^   ^            |         ^
|        // //       /   /             |        // : kobject->kset
|                                      |
|   -----------		 -----------       |        ^
<---| kobject | <--- | kobject | <------       /   : kobject->parent
    -----------      -----------

* Operations on kset:
	void kset_init(struct kset *kset);  
	int kset_register(struct kset *kset); // initialize and add a kset
	void kset_unregister(struct kset *kset);
	struct kset *kset_get(struct kset *kset); // manage the reference counts of ksets.
	void kset_put(struct kset *kset);
Note that a kset's ref_cnt is actually its embedded kobject's reference count.


2. Low-level sysfs operations:
For every directory found in sysfs, there is a kobject lurking somewhere within the kernel (kobject is embedded in kset). Every kobject of interest also exports one or more attributes, which appear in that kobject's sysfs directory as files containing kernel-generated information.
• kobject_add() see LKD/chapter_17's notes. Sysfs entries for kobjects are always directories, so a call to kobject_add() results in the creation of a directory in sysfs. Usually that directory contains one or more attributes.
i) Default attributes:
When created, every kobject is given a set of default attributes. These attributes are specified by way of the kobj_type structure:
	struct kobj_type {
		void (*release)(struct kobject *);
		struct sysfs_ops *sysfs_ops;
		struct attribute **default_attrs;
	};
The @default_attrs field lists the attributes to be created for _EVERY_ kobject of this type, and sysfs_ops provides the methods to implement those attributes. Note that the last entry in @default_attrs must be NULL.
	struct sysfs_ops {
		ssize_t (*show)(struct kobject *kobj, struct attribute *attr, char *buffer);
		ssize_t (*store)(struct kobject *kobj, struct attribute *attr, const char *buffer, size_t size);
	};
The same show/store method is used for all attributes associated with a given kobject. (See fs/sysfs/file.c: fill_read_buffer(), flush_write_buffer(). See also drivers/base/core.c: device_initialize(), device_ktype, etc.) The 
