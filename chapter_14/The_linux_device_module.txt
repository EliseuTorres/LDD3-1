1. Kobject, kobj_type, and kset:
Kobject subsystem handles the generation of events that notify user space about the comings and goings of hardware on the system.
i) Kobject basics (also see LKD/chapter_17):
It's rare for kernel code to create a standalone kobject, instead, kobjects are always found embedded in other structures.

• kobject initialization:
* The first is to set the entire kobject to 0, usually with a call to memset(). Failure to zero out a kobject often leads to very strange crashes further down the line, this step shouldn't be omitted.
* The next step is to set up some of the internal fields with a call to kobject_init(): (also see LKD/chapter_17)
	void kobject_init(struct kobject *kobj, struct kobj_type *ktype);
	int kobject_set_name(struct kobject *kobj, const char *fmt, ...); // set the name of the kobject, which is used in sysfs entries. Note that this call may fail, so you should check its return value.

• Reference count manipulation:
	struct kobject *kobject_get(struct kobject *kobj); // Increase kobj's ref_cnt by 1.
	void kobject_put(struct kobject *kobj);  // Decrease kobj's ref_cnt by 1, and if it becomes 0, the release() function pointed at by the kobj_type associated with the kobject is invoked.
Note that in many cases, the reference count in the kobject itself may not be sufficient to prevent race conditions. The existence of a kobject may require the continued existence of the module that created that kobject. It would not do to unload that module while the kobject is still being passed around. See source code of cdev_get().

• Release functions and kobj_type:
Every kobject must have a release() method, which is embedded in kobj_type.
	struct kobj_type *get_ktype(struct kobject *kobj);  // finds the kobj_type pointer for a given kobject.

• kobject hierarchies, kset:
* kobject structure has a parent pointer, which is used to position the object in the sysfs hierarchy.
* kset is used as containment, it can be thought of as the top-level container class for kobjects. It's worth noting that ksets are always represented in sysfs once a kset has been set up and added to the system, there will be a sysfs directory for it. Kobjects do not necessarily show up in sysfs, but every kobject that is a member of a kset is represented there.
	int kobject_add(struct kobject *kobj, struct kobject *parent, const char *fmt, ...); // see LKD/chapter_17 for more details.
	void kobject_del(struct kobject *kobj); // Remove a kobject's sysfs representation
* A kset keeps its children in a standard kernel linked list. In almost all cases, the contained kobjects also have pointers (parent pointer) to the kset (or strictly, kset's embedded kobject)
        ----------------------
        | kset   ----------- | 
|------>|        | kobject | |----------     ----> : kset child list
|       ----------------------         |           
|         ^  ^        ^   ^            |         ^
|        // //       /   /             |        // : kobject->kset
|                                      |
|   -----------		 -----------       |        ^
<---| kobject | <--- | kobject | <------       /   : kobject->parent
    -----------      -----------

* Operations on kset:
	void kset_init(struct kset *kset);  
	int kset_register(struct kset *kset); // initialize and add a kset
	void kset_unregister(struct kset *kset);
	struct kset *kset_get(struct kset *kset); // manage the reference counts of ksets.
	void kset_put(struct kset *kset);
Note that a kset's ref_cnt is actually its embedded kobject's reference count.


2. Low-level sysfs operations:
For every directory found in sysfs, there is a kobject lurking somewhere within the kernel (kobject is embedded in kset). Every kobject of interest also exports one or more attributes, which appear in that kobject's sysfs directory as files containing kernel-generated information.
• kobject_add() see LKD/chapter_17's notes. Sysfs entries for kobjects are always directories, so a call to kobject_add() results in the creation of a directory in sysfs. Usually that directory contains one or more attributes.
i)   Default attributes:
When created, every kobject is given a set of default attributes. These attributes are specified by way of the kobj_type structure:
	struct kobj_type {
		void (*release)(struct kobject *);
		struct sysfs_ops *sysfs_ops;
		struct attribute **default_attrs;
	};
The @default_attrs field lists the attributes to be created for _EVERY_ kobject of this type, and sysfs_ops provides the methods to implement those attributes. Note that the last entry in @default_attrs must be NULL.
	struct sysfs_ops {
		ssize_t (*show)(struct kobject *kobj, struct attribute *attr, char *buffer);
		ssize_t (*store)(struct kobject *kobj, struct attribute *attr, const char *buffer, size_t size);
	};
The same show/store method is used for all attributes associated with a given kobject. (See fs/sysfs/file.c: fill_read_buffer(), flush_write_buffer(). See also drivers/base/core.c: device_initialize(), device_ktype, etc.) The show() method should encode the value into buffer, which length is limited to PAGE_SIZE. The store() method should decode the data stored in buffer and respond to the kernel, note that you should validate it carefully because it comes from user space.
• Nondefault attributes:
If you wish to add a new attribute to a kobject's sysfs directory:
	int sysfs_create_file(struct kobject *kobj, struct attribute *attr);
Note that the same show() and store() functions are called to implement operations on the new attribute.

ii)  Binary attributes:
Here's need to pass large chunks of binary data between user space and kernel space, like uploading firmware to devices. 
	struct bin_attribute {
		struct attribute attr;
		size_t size;
		void *private;
		ssize_t (*read)(struct kobject *kobj, struct bin_attribute *bin_attr, char *buffer, loff_t pos, size_t size);
		ssize_t (*write)(struct kobject *kobj, struct bin_attribute *bin_attr, char *buffer, loff_t pos, size_t size);
		int (*mmap)(struct kobject *kobj, struct bin_attribute *bin_attr, struct vm_area_struct *vma);
	};
The @size is the maximum size of the binary attribute (or 0 if there is no maximum). Note there's no way for sysfs to signal the last of a set of write operations, so code implementing a binary attribute must be able to determine the end of the data some other way.
	int sysfs_create_bin_file(struct kobject *kobj, struct bin_attribute *attr);
	int sysfs_remove_bin_file(struct kobject *kobj, struct bin_attribute *attr);

iii) Symbolic links:
	int sysfs_create_link(struct kobject *kobj, struct kobject *target, const char *name); // Creates a link (called @name) pointing to target's sysfs entry as an attribute of kobj.
	void sysfs_remove_link(struct kobject *kobj, const char *name);
Note that the link persists even if target is removed from the system. So you should probably have a way of knowing about changes to those kobjects or some sort of assurance that the target kobjects will not disappear.

iv)  Hotplug event generation (uevent):


